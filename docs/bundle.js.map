{"version":3,"file":"bundle.js","sources":["../node_modules/svelte/shared.js","../src/ChoosePlayers.html","../node_modules/string-convert/camel2hyphen.js","../node_modules/json2mq/index.js","../src/Media.html","../src/Play.html","../src/App.html","../node_modules/svelte/store.js","../src/helpers.js","../src/main.js"],"sourcesContent":["function noop() {}\n\nfunction assign(tar, src) {\n\tfor (var k in src) tar[k] = src[k];\n\treturn tar;\n}\n\nfunction assignTrue(tar, src) {\n\tfor (var k in src) tar[k] = 1;\n\treturn tar;\n}\n\nfunction isPromise(value) {\n\treturn value && typeof value.then === 'function';\n}\n\nfunction callAfter(fn, i) {\n\tif (i === 0) fn();\n\treturn () => {\n\t\tif (!--i) fn();\n\t};\n}\n\nfunction addLoc(element, file, line, column, char) {\n\telement.__svelte_meta = {\n\t\tloc: { file, line, column, char }\n\t};\n}\n\nfunction exclude(src, prop) {\n\tconst tar = {};\n\tfor (const k in src) k === prop || (tar[k] = src[k]);\n\treturn tar;\n}\n\nfunction run(fn) {\n\tfn();\n}\n\nfunction append(target, node) {\n\ttarget.appendChild(node);\n}\n\nfunction insert(target, node, anchor) {\n\ttarget.insertBefore(node, anchor);\n}\n\nfunction detachNode(node) {\n\tnode.parentNode.removeChild(node);\n}\n\nfunction detachBetween(before, after) {\n\twhile (before.nextSibling && before.nextSibling !== after) {\n\t\tbefore.parentNode.removeChild(before.nextSibling);\n\t}\n}\n\nfunction detachBefore(after) {\n\twhile (after.previousSibling) {\n\t\tafter.parentNode.removeChild(after.previousSibling);\n\t}\n}\n\nfunction detachAfter(before) {\n\twhile (before.nextSibling) {\n\t\tbefore.parentNode.removeChild(before.nextSibling);\n\t}\n}\n\nfunction reinsertBetween(before, after, target) {\n\twhile (before.nextSibling && before.nextSibling !== after) {\n\t\ttarget.appendChild(before.parentNode.removeChild(before.nextSibling));\n\t}\n}\n\nfunction reinsertChildren(parent, target) {\n\twhile (parent.firstChild) target.appendChild(parent.firstChild);\n}\n\nfunction reinsertAfter(before, target) {\n\twhile (before.nextSibling) target.appendChild(before.nextSibling);\n}\n\nfunction reinsertBefore(after, target) {\n\tvar parent = after.parentNode;\n\twhile (parent.firstChild !== after) target.appendChild(parent.firstChild);\n}\n\nfunction destroyEach(iterations, detach) {\n\tfor (var i = 0; i < iterations.length; i += 1) {\n\t\tif (iterations[i]) iterations[i].d(detach);\n\t}\n}\n\nfunction createFragment() {\n\treturn document.createDocumentFragment();\n}\n\nfunction createElement(name) {\n\treturn document.createElement(name);\n}\n\nfunction createSvgElement(name) {\n\treturn document.createElementNS('http://www.w3.org/2000/svg', name);\n}\n\nfunction createText(data) {\n\treturn document.createTextNode(data);\n}\n\nfunction createComment() {\n\treturn document.createComment('');\n}\n\nfunction addListener(node, event, handler, options) {\n\tnode.addEventListener(event, handler, options);\n}\n\nfunction removeListener(node, event, handler, options) {\n\tnode.removeEventListener(event, handler, options);\n}\n\nfunction setAttribute(node, attribute, value) {\n\tif (value == null) node.removeAttribute(attribute);\n\telse node.setAttribute(attribute, value);\n}\n\nfunction setAttributes(node, attributes) {\n\tfor (var key in attributes) {\n\t\tif (key === 'style') {\n\t\t\tnode.style.cssText = attributes[key];\n\t\t} else if (key in node) {\n\t\t\tnode[key] = attributes[key];\n\t\t} else {\n\t\t\tsetAttribute(node, key, attributes[key]);\n\t\t}\n\t}\n}\n\nfunction setCustomElementData(node, prop, value) {\n\tif (prop in node) {\n\t\tnode[prop] = value;\n\t} else {\n\t\tsetAttribute(node, prop, value);\n\t}\n}\n\nfunction setXlinkAttribute(node, attribute, value) {\n\tnode.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\n\nfunction getBindingGroupValue(group) {\n\tvar value = [];\n\tfor (var i = 0; i < group.length; i += 1) {\n\t\tif (group[i].checked) value.push(group[i].__value);\n\t}\n\treturn value;\n}\n\nfunction toNumber(value) {\n\treturn value === '' ? undefined : +value;\n}\n\nfunction timeRangesToArray(ranges) {\n\tvar array = [];\n\tfor (var i = 0; i < ranges.length; i += 1) {\n\t\tarray.push({ start: ranges.start(i), end: ranges.end(i) });\n\t}\n\treturn array;\n}\n\nfunction children (element) {\n\treturn Array.from(element.childNodes);\n}\n\nfunction claimElement (nodes, name, attributes, svg) {\n\tfor (var i = 0; i < nodes.length; i += 1) {\n\t\tvar node = nodes[i];\n\t\tif (node.nodeName === name) {\n\t\t\tfor (var j = 0; j < node.attributes.length; j += 1) {\n\t\t\t\tvar attribute = node.attributes[j];\n\t\t\t\tif (!attributes[attribute.name]) node.removeAttribute(attribute.name);\n\t\t\t}\n\t\t\treturn nodes.splice(i, 1)[0]; // TODO strip unwanted attributes\n\t\t}\n\t}\n\n\treturn svg ? createSvgElement(name) : createElement(name);\n}\n\nfunction claimText (nodes, data) {\n\tfor (var i = 0; i < nodes.length; i += 1) {\n\t\tvar node = nodes[i];\n\t\tif (node.nodeType === 3) {\n\t\t\tnode.data = data;\n\t\t\treturn nodes.splice(i, 1)[0];\n\t\t}\n\t}\n\n\treturn createText(data);\n}\n\nfunction setData(text, data) {\n\ttext.data = '' + data;\n}\n\nfunction setInputType(input, type) {\n\ttry {\n\t\tinput.type = type;\n\t} catch (e) {}\n}\n\nfunction setStyle(node, key, value) {\n\tnode.style.setProperty(key, value);\n}\n\nfunction selectOption(select, value) {\n\tfor (var i = 0; i < select.options.length; i += 1) {\n\t\tvar option = select.options[i];\n\n\t\tif (option.__value === value) {\n\t\t\toption.selected = true;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nfunction selectOptions(select, value) {\n\tfor (var i = 0; i < select.options.length; i += 1) {\n\t\tvar option = select.options[i];\n\t\toption.selected = ~value.indexOf(option.__value);\n\t}\n}\n\nfunction selectValue(select) {\n\tvar selectedOption = select.querySelector(':checked') || select.options[0];\n\treturn selectedOption && selectedOption.__value;\n}\n\nfunction selectMultipleValue(select) {\n\treturn [].map.call(select.querySelectorAll(':checked'), function(option) {\n\t\treturn option.__value;\n\t});\n}\n\nfunction addResizeListener(element, fn) {\n\tif (getComputedStyle(element).position === 'static') {\n\t\telement.style.position = 'relative';\n\t}\n\n\tconst object = document.createElement('object');\n\tobject.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;');\n\tobject.type = 'text/html';\n\n\tlet win;\n\n\tobject.onload = () => {\n\t\twin = object.contentDocument.defaultView;\n\t\twin.addEventListener('resize', fn);\n\t};\n\n\tif (/Trident/.test(navigator.userAgent)) {\n\t\telement.appendChild(object);\n\t\tobject.data = 'about:blank';\n\t} else {\n\t\tobject.data = 'about:blank';\n\t\telement.appendChild(object);\n\t}\n\n\treturn {\n\t\tcancel: () => {\n\t\t\twin && win.removeEventListener && win.removeEventListener('resize', fn);\n\t\t\telement.removeChild(object);\n\t\t}\n\t};\n}\n\nfunction toggleClass(element, name, toggle) {\n\telement.classList[toggle ? 'add' : 'remove'](name);\n}\n\nfunction linear(t) {\n\treturn t;\n}\n\nfunction generateRule({ a, b, delta, duration }, ease, fn) {\n\tconst step = 16.666 / duration;\n\tlet keyframes = '{\\n';\n\n\tfor (let p = 0; p <= 1; p += step) {\n\t\tconst t = a + delta * ease(p);\n\t\tkeyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n\t}\n\n\treturn keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n}\n\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n\tlet hash = 5381;\n\tlet i = str.length;\n\n\twhile (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n\treturn hash >>> 0;\n}\n\nfunction wrapTransition(component, node, fn, params, intro) {\n\tlet obj = fn.call(component, node, params);\n\tlet duration;\n\tlet ease;\n\tlet cssText;\n\n\tlet initialised = false;\n\n\treturn {\n\t\tt: intro ? 0 : 1,\n\t\trunning: false,\n\t\tprogram: null,\n\t\tpending: null,\n\n\t\trun(b, callback) {\n\t\t\tif (typeof obj === 'function') {\n\t\t\t\ttransitionManager.wait().then(() => {\n\t\t\t\t\tobj = obj();\n\t\t\t\t\tthis._run(b, callback);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis._run(b, callback);\n\t\t\t}\n\t\t},\n\n\t\t_run(b, callback) {\n\t\t\tduration = obj.duration || 300;\n\t\t\tease = obj.easing || linear;\n\n\t\t\tconst program = {\n\t\t\t\tstart: window.performance.now() + (obj.delay || 0),\n\t\t\t\tb,\n\t\t\t\tcallback: callback || noop\n\t\t\t};\n\n\t\t\tif (intro && !initialised) {\n\t\t\t\tif (obj.css && obj.delay) {\n\t\t\t\t\tcssText = node.style.cssText;\n\t\t\t\t\tnode.style.cssText += obj.css(0, 1);\n\t\t\t\t}\n\n\t\t\t\tif (obj.tick) obj.tick(0, 1);\n\t\t\t\tinitialised = true;\n\t\t\t}\n\n\t\t\tif (!b) {\n\t\t\t\tprogram.group = outros.current;\n\t\t\t\toutros.current.remaining += 1;\n\t\t\t}\n\n\t\t\tif (obj.delay) {\n\t\t\t\tthis.pending = program;\n\t\t\t} else {\n\t\t\t\tthis.start(program);\n\t\t\t}\n\n\t\t\tif (!this.running) {\n\t\t\t\tthis.running = true;\n\t\t\t\ttransitionManager.add(this);\n\t\t\t}\n\t\t},\n\n\t\tstart(program) {\n\t\t\tcomponent.fire(`${program.b ? 'intro' : 'outro'}.start`, { node });\n\n\t\t\tprogram.a = this.t;\n\t\t\tprogram.delta = program.b - program.a;\n\t\t\tprogram.duration = duration * Math.abs(program.b - program.a);\n\t\t\tprogram.end = program.start + program.duration;\n\n\t\t\tif (obj.css) {\n\t\t\t\tif (obj.delay) node.style.cssText = cssText;\n\n\t\t\t\tconst rule = generateRule(program, ease, obj.css);\n\t\t\t\ttransitionManager.addRule(rule, program.name = '__svelte_' + hash(rule));\n\n\t\t\t\tnode.style.animation = (node.style.animation || '')\n\t\t\t\t\t.split(', ')\n\t\t\t\t\t.filter(anim => anim && (program.delta < 0 || !/__svelte/.test(anim)))\n\t\t\t\t\t.concat(`${program.name} ${program.duration}ms linear 1 forwards`)\n\t\t\t\t\t.join(', ');\n\t\t\t}\n\n\t\t\tthis.program = program;\n\t\t\tthis.pending = null;\n\t\t},\n\n\t\tupdate(now) {\n\t\t\tconst program = this.program;\n\t\t\tif (!program) return;\n\n\t\t\tconst p = now - program.start;\n\t\t\tthis.t = program.a + program.delta * ease(p / program.duration);\n\t\t\tif (obj.tick) obj.tick(this.t, 1 - this.t);\n\t\t},\n\n\t\tdone() {\n\t\t\tconst program = this.program;\n\t\t\tthis.t = program.b;\n\n\t\t\tif (obj.tick) obj.tick(this.t, 1 - this.t);\n\n\t\t\tcomponent.fire(`${program.b ? 'intro' : 'outro'}.end`, { node });\n\n\t\t\tif (!program.b && !program.invalidated) {\n\t\t\t\tprogram.group.callbacks.push(() => {\n\t\t\t\t\tprogram.callback();\n\t\t\t\t\tif (obj.css) transitionManager.deleteRule(node, program.name);\n\t\t\t\t});\n\n\t\t\t\tif (--program.group.remaining === 0) {\n\t\t\t\t\tprogram.group.callbacks.forEach(run);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (obj.css) transitionManager.deleteRule(node, program.name);\n\t\t\t}\n\n\t\t\tthis.running = !!this.pending;\n\t\t},\n\n\t\tabort(reset) {\n\t\t\tif (this.program) {\n\t\t\t\tif (reset && obj.tick) obj.tick(1, 0);\n\t\t\t\tif (obj.css) transitionManager.deleteRule(node, this.program.name);\n\t\t\t\tthis.program = this.pending = null;\n\t\t\t\tthis.running = false;\n\t\t\t}\n\t\t},\n\n\t\tinvalidate() {\n\t\t\tif (this.program) {\n\t\t\t\tthis.program.invalidated = true;\n\t\t\t}\n\t\t}\n\t};\n}\n\nlet outros = {};\n\nfunction groupOutros() {\n\toutros.current = {\n\t\tremaining: 0,\n\t\tcallbacks: []\n\t};\n}\n\nvar transitionManager = {\n\trunning: false,\n\ttransitions: [],\n\tbound: null,\n\tstylesheet: null,\n\tactiveRules: {},\n\tpromise: null,\n\n\tadd(transition) {\n\t\tthis.transitions.push(transition);\n\n\t\tif (!this.running) {\n\t\t\tthis.running = true;\n\t\t\trequestAnimationFrame(this.bound || (this.bound = this.next.bind(this)));\n\t\t}\n\t},\n\n\taddRule(rule, name) {\n\t\tif (!this.stylesheet) {\n\t\t\tconst style = createElement('style');\n\t\t\tdocument.head.appendChild(style);\n\t\t\ttransitionManager.stylesheet = style.sheet;\n\t\t}\n\n\t\tif (!this.activeRules[name]) {\n\t\t\tthis.activeRules[name] = true;\n\t\t\tthis.stylesheet.insertRule(`@keyframes ${name} ${rule}`, this.stylesheet.cssRules.length);\n\t\t}\n\t},\n\n\tnext() {\n\t\tthis.running = false;\n\n\t\tconst now = window.performance.now();\n\t\tlet i = this.transitions.length;\n\n\t\twhile (i--) {\n\t\t\tconst transition = this.transitions[i];\n\n\t\t\tif (transition.program && now >= transition.program.end) {\n\t\t\t\ttransition.done();\n\t\t\t}\n\n\t\t\tif (transition.pending && now >= transition.pending.start) {\n\t\t\t\ttransition.start(transition.pending);\n\t\t\t}\n\n\t\t\tif (transition.running) {\n\t\t\t\ttransition.update(now);\n\t\t\t\tthis.running = true;\n\t\t\t} else if (!transition.pending) {\n\t\t\t\tthis.transitions.splice(i, 1);\n\t\t\t}\n\t\t}\n\n\t\tif (this.running) {\n\t\t\trequestAnimationFrame(this.bound);\n\t\t} else if (this.stylesheet) {\n\t\t\tlet i = this.stylesheet.cssRules.length;\n\t\t\twhile (i--) this.stylesheet.deleteRule(i);\n\t\t\tthis.activeRules = {};\n\t\t}\n\t},\n\n\tdeleteRule(node, name) {\n\t\tnode.style.animation = node.style.animation\n\t\t\t.split(', ')\n\t\t\t.filter(anim => anim && anim.indexOf(name) === -1)\n\t\t\t.join(', ');\n\t},\n\n\twait() {\n\t\tif (!transitionManager.promise) {\n\t\t\ttransitionManager.promise = Promise.resolve();\n\t\t\ttransitionManager.promise.then(() => {\n\t\t\t\ttransitionManager.promise = null;\n\t\t\t});\n\t\t}\n\n\t\treturn transitionManager.promise;\n\t}\n};\n\nfunction wrapAnimation(node, from, fn, params) {\n\tif (!from) return;\n\n\tconst to = node.getBoundingClientRect();\n\tif (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom) return;\n\n\tconst info = fn(node, { from, to }, params);\n\n\tconst duration = 'duration' in info ? info.duration : 300;\n\tconst delay = 'delay' in info ? info.delay : 0;\n\tconst ease = info.easing || linear;\n\tconst start = window.performance.now() + delay;\n\tconst end = start + duration;\n\n\tconst program = {\n\t\ta: 0,\n\t\tt: 0,\n\t\tb: 1,\n\t\tdelta: 1,\n\t\tduration,\n\t\tstart,\n\t\tend\n\t};\n\n\tconst cssText = node.style.cssText;\n\n\tconst animation = {\n\t\tpending: delay ? program : null,\n\t\tprogram: delay ? null : program,\n\t\trunning: true,\n\n\t\tstart() {\n\t\t\tif (info.css) {\n\t\t\t\tif (delay) node.style.cssText = cssText;\n\n\t\t\t\tconst rule = generateRule(program, ease, info.css);\n\t\t\t\tprogram.name = `__svelte_${hash(rule)}`;\n\n\t\t\t\ttransitionManager.addRule(rule, program.name);\n\n\t\t\t\tnode.style.animation = (node.style.animation || '')\n\t\t\t\t\t.split(', ')\n\t\t\t\t\t.filter(anim => anim && (program.delta < 0 || !/__svelte/.test(anim)))\n\t\t\t\t\t.concat(`${program.name} ${program.duration}ms linear 1 forwards`)\n\t\t\t\t\t.join(', ');\n\t\t\t}\n\n\t\t\tanimation.program = program;\n\t\t\tanimation.pending = null;\n\t\t},\n\n\t\tupdate: now => {\n\t\t\tconst p = now - program.start;\n\t\t\tconst t = program.a + program.delta * ease(p / program.duration);\n\t\t\tif (info.tick) info.tick(t, 1 - t);\n\t\t},\n\n\t\tdone() {\n\t\t\tif (info.tick) info.tick(1, 0);\n\t\t\tanimation.stop();\n\t\t},\n\n\t\tstop() {\n\t\t\tif (info.css) transitionManager.deleteRule(node, program.name);\n\t\t\tanimation.running = false;\n\t\t}\n\t};\n\n\ttransitionManager.add(animation);\n\n\tif (info.tick) info.tick(0, 1);\n\n\tif (delay) {\n\t\tif (info.css) node.style.cssText += info.css(0, 1);\n\t} else {\n\t\tanimation.start();\n\t}\n\n\treturn animation;\n}\n\nfunction fixPosition(node) {\n\tconst style = getComputedStyle(node);\n\n\tif (style.position !== 'absolute' && style.position !== 'fixed') {\n\t\tconst { width, height } = style;\n\t\tconst a = node.getBoundingClientRect();\n\t\tnode.style.position = 'absolute';\n\t\tnode.style.width = width;\n\t\tnode.style.height = height;\n\t\tconst b = node.getBoundingClientRect();\n\n\t\tif (a.left !== b.left || a.top !== b.top) {\n\t\t\tconst style = getComputedStyle(node);\n\t\t\tconst transform = style.transform === 'none' ? '' : style.transform;\n\n\t\t\tnode.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n\t\t}\n\t}\n}\n\nfunction handlePromise(promise, info) {\n\tvar token = info.token = {};\n\n\tfunction update(type, index, key, value) {\n\t\tif (info.token !== token) return;\n\n\t\tinfo.resolved = key && { [key]: value };\n\n\t\tconst child_ctx = assign(assign({}, info.ctx), info.resolved);\n\t\tconst block = type && (info.current = type)(info.component, child_ctx);\n\n\t\tif (info.block) {\n\t\t\tif (info.blocks) {\n\t\t\t\tinfo.blocks.forEach((block, i) => {\n\t\t\t\t\tif (i !== index && block) {\n\t\t\t\t\t\tgroupOutros();\n\t\t\t\t\t\tblock.o(() => {\n\t\t\t\t\t\t\tblock.d(1);\n\t\t\t\t\t\t\tinfo.blocks[i] = null;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tinfo.block.d(1);\n\t\t\t}\n\n\t\t\tblock.c();\n\t\t\tblock[block.i ? 'i' : 'm'](info.mount(), info.anchor);\n\n\t\t\tinfo.component.root.set({}); // flush any handlers that were created\n\t\t}\n\n\t\tinfo.block = block;\n\t\tif (info.blocks) info.blocks[index] = block;\n\t}\n\n\tif (isPromise(promise)) {\n\t\tpromise.then(value => {\n\t\t\tupdate(info.then, 1, info.value, value);\n\t\t}, error => {\n\t\t\tupdate(info.catch, 2, info.error, error);\n\t\t});\n\n\t\t// if we previously had a then/catch block, destroy it\n\t\tif (info.current !== info.pending) {\n\t\t\tupdate(info.pending, 0);\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\tif (info.current !== info.then) {\n\t\t\tupdate(info.then, 1, info.value, promise);\n\t\t\treturn true;\n\t\t}\n\n\t\tinfo.resolved = { [info.value]: promise };\n\t}\n}\n\nfunction destroyBlock(block, lookup) {\n\tblock.d(1);\n\tlookup[block.key] = null;\n}\n\nfunction outroAndDestroyBlock(block, lookup) {\n\tblock.o(function() {\n\t\tdestroyBlock(block, lookup);\n\t});\n}\n\nfunction fixAndOutroAndDestroyBlock(block, lookup) {\n\tblock.f();\n\toutroAndDestroyBlock(block, lookup);\n}\n\nfunction updateKeyedEach(old_blocks, component, changed, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, intro_method, next, get_context) {\n\tvar o = old_blocks.length;\n\tvar n = list.length;\n\n\tvar i = o;\n\tvar old_indexes = {};\n\twhile (i--) old_indexes[old_blocks[i].key] = i;\n\n\tvar new_blocks = [];\n\tvar new_lookup = {};\n\tvar deltas = {};\n\n\tvar i = n;\n\twhile (i--) {\n\t\tvar child_ctx = get_context(ctx, list, i);\n\t\tvar key = get_key(child_ctx);\n\t\tvar block = lookup[key];\n\n\t\tif (!block) {\n\t\t\tblock = create_each_block(component, key, child_ctx);\n\t\t\tblock.c();\n\t\t} else if (dynamic) {\n\t\t\tblock.p(changed, child_ctx);\n\t\t}\n\n\t\tnew_blocks[i] = new_lookup[key] = block;\n\n\t\tif (key in old_indexes) deltas[key] = Math.abs(i - old_indexes[key]);\n\t}\n\n\tvar will_move = {};\n\tvar did_move = {};\n\n\tfunction insert(block) {\n\t\tblock[intro_method](node, next);\n\t\tlookup[block.key] = block;\n\t\tnext = block.first;\n\t\tn--;\n\t}\n\n\twhile (o && n) {\n\t\tvar new_block = new_blocks[n - 1];\n\t\tvar old_block = old_blocks[o - 1];\n\t\tvar new_key = new_block.key;\n\t\tvar old_key = old_block.key;\n\n\t\tif (new_block === old_block) {\n\t\t\t// do nothing\n\t\t\tnext = new_block.first;\n\t\t\to--;\n\t\t\tn--;\n\t\t}\n\n\t\telse if (!new_lookup[old_key]) {\n\t\t\t// remove old block\n\t\t\tdestroy(old_block, lookup);\n\t\t\to--;\n\t\t}\n\n\t\telse if (!lookup[new_key] || will_move[new_key]) {\n\t\t\tinsert(new_block);\n\t\t}\n\n\t\telse if (did_move[old_key]) {\n\t\t\to--;\n\n\t\t} else if (deltas[new_key] > deltas[old_key]) {\n\t\t\tdid_move[new_key] = true;\n\t\t\tinsert(new_block);\n\n\t\t} else {\n\t\t\twill_move[old_key] = true;\n\t\t\to--;\n\t\t}\n\t}\n\n\twhile (o--) {\n\t\tvar old_block = old_blocks[o];\n\t\tif (!new_lookup[old_block.key]) destroy(old_block, lookup);\n\t}\n\n\twhile (n) insert(new_blocks[n - 1]);\n\n\treturn new_blocks;\n}\n\nfunction measure(blocks) {\n\tconst rects = {};\n\tlet i = blocks.length;\n\twhile (i--) rects[blocks[i].key] = blocks[i].node.getBoundingClientRect();\n\treturn rects;\n}\n\nfunction animate(blocks, rects, fn, params) {\n\tlet i = blocks.length;\n\twhile (i--) {\n\t\tconst block = blocks[i];\n\t\tconst from = rects[block.key];\n\n\t\tif (!from) continue;\n\t\tconst to = block.node.getBoundingClientRect();\n\n\t\tif (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom) continue;\n\n\n\t}\n}\n\nfunction getSpreadUpdate(levels, updates) {\n\tvar update = {};\n\n\tvar to_null_out = {};\n\tvar accounted_for = {};\n\n\tvar i = levels.length;\n\twhile (i--) {\n\t\tvar o = levels[i];\n\t\tvar n = updates[i];\n\n\t\tif (n) {\n\t\t\tfor (var key in o) {\n\t\t\t\tif (!(key in n)) to_null_out[key] = 1;\n\t\t\t}\n\n\t\t\tfor (var key in n) {\n\t\t\t\tif (!accounted_for[key]) {\n\t\t\t\t\tupdate[key] = n[key];\n\t\t\t\t\taccounted_for[key] = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlevels[i] = n;\n\t\t} else {\n\t\t\tfor (var key in o) {\n\t\t\t\taccounted_for[key] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (var key in to_null_out) {\n\t\tif (!(key in update)) update[key] = undefined;\n\t}\n\n\treturn update;\n}\n\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nconst invalidAttributeNameCharacter = /[\\s'\">\\/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n\nfunction spread(args) {\n\tconst attributes = Object.assign({}, ...args);\n\tlet str = '';\n\n\tObject.keys(attributes).forEach(name => {\n\t\tif (invalidAttributeNameCharacter.test(name)) return;\n\n\t\tconst value = attributes[name];\n\t\tif (value === undefined) return;\n\t\tif (value === true) str += \" \" + name;\n\n\t\tconst escaped = String(value)\n\t\t\t.replace(/\"/g, '&#34;')\n\t\t\t.replace(/'/g, '&#39;');\n\n\t\tstr += \" \" + name + \"=\" + JSON.stringify(escaped);\n\t});\n\n\treturn str;\n}\n\nconst escaped = {\n\t'\"': '&quot;',\n\t\"'\": '&#39;',\n\t'&': '&amp;',\n\t'<': '&lt;',\n\t'>': '&gt;'\n};\n\nfunction escape(html) {\n\treturn String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\n\nfunction each(items, assign, fn) {\n\tlet str = '';\n\tfor (let i = 0; i < items.length; i += 1) {\n\t\tstr += fn(assign(items[i], i));\n\t}\n\treturn str;\n}\n\nconst missingComponent = {\n\t_render: () => ''\n};\n\nfunction validateSsrComponent(component, name) {\n\tif (!component || !component._render) {\n\t\tif (name === 'svelte:component') name += ' this={...}';\n\t\tthrow new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n\t}\n\n\treturn component;\n}\n\nfunction debug(file, line, column, values) {\n\tconsole.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`);\n\tconsole.log(values);\n\treturn '';\n}\n\nfunction blankObject() {\n\treturn Object.create(null);\n}\n\nfunction destroy(detach) {\n\tthis.destroy = noop;\n\tthis.fire('destroy');\n\tthis.set = noop;\n\n\tthis._fragment.d(detach !== false);\n\tthis._fragment = null;\n\tthis._state = {};\n}\n\nfunction destroyDev(detach) {\n\tdestroy.call(this, detach);\n\tthis.destroy = function() {\n\t\tconsole.warn('Component was already destroyed');\n\t};\n}\n\nfunction _differs(a, b) {\n\treturn a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\n\nfunction _differsImmutable(a, b) {\n\treturn a != a ? b == b : a !== b;\n}\n\nfunction fire(eventName, data) {\n\tvar handlers =\n\t\teventName in this._handlers && this._handlers[eventName].slice();\n\tif (!handlers) return;\n\n\tfor (var i = 0; i < handlers.length; i += 1) {\n\t\tvar handler = handlers[i];\n\n\t\tif (!handler.__calling) {\n\t\t\ttry {\n\t\t\t\thandler.__calling = true;\n\t\t\t\thandler.call(this, data);\n\t\t\t} finally {\n\t\t\t\thandler.__calling = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction flush(component) {\n\tcomponent._lock = true;\n\tcallAll(component._beforecreate);\n\tcallAll(component._oncreate);\n\tcallAll(component._aftercreate);\n\tcomponent._lock = false;\n}\n\nfunction get() {\n\treturn this._state;\n}\n\nfunction init(component, options) {\n\tcomponent._handlers = blankObject();\n\tcomponent._slots = blankObject();\n\tcomponent._bind = options._bind;\n\tcomponent._staged = {};\n\n\tcomponent.options = options;\n\tcomponent.root = options.root || component;\n\tcomponent.store = options.store || component.root.store;\n\n\tif (!options.root) {\n\t\tcomponent._beforecreate = [];\n\t\tcomponent._oncreate = [];\n\t\tcomponent._aftercreate = [];\n\t}\n}\n\nfunction on(eventName, handler) {\n\tvar handlers = this._handlers[eventName] || (this._handlers[eventName] = []);\n\thandlers.push(handler);\n\n\treturn {\n\t\tcancel: function() {\n\t\t\tvar index = handlers.indexOf(handler);\n\t\t\tif (~index) handlers.splice(index, 1);\n\t\t}\n\t};\n}\n\nfunction set(newState) {\n\tthis._set(assign({}, newState));\n\tif (this.root._lock) return;\n\tflush(this.root);\n}\n\nfunction _set(newState) {\n\tvar oldState = this._state,\n\t\tchanged = {},\n\t\tdirty = false;\n\n\tnewState = assign(this._staged, newState);\n\tthis._staged = {};\n\n\tfor (var key in newState) {\n\t\tif (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;\n\t}\n\tif (!dirty) return;\n\n\tthis._state = assign(assign({}, oldState), newState);\n\tthis._recompute(changed, this._state);\n\tif (this._bind) this._bind(changed, this._state);\n\n\tif (this._fragment) {\n\t\tthis.fire(\"state\", { changed: changed, current: this._state, previous: oldState });\n\t\tthis._fragment.p(changed, this._state);\n\t\tthis.fire(\"update\", { changed: changed, current: this._state, previous: oldState });\n\t}\n}\n\nfunction _stage(newState) {\n\tassign(this._staged, newState);\n}\n\nfunction setDev(newState) {\n\tif (typeof newState !== 'object') {\n\t\tthrow new Error(\n\t\t\tthis._debugName + '.set was called without an object of data key-values to update.'\n\t\t);\n\t}\n\n\tthis._checkReadOnly(newState);\n\tset.call(this, newState);\n}\n\nfunction callAll(fns) {\n\twhile (fns && fns.length) fns.shift()();\n}\n\nfunction _mount(target, anchor) {\n\tthis._fragment[this._fragment.i ? 'i' : 'm'](target, anchor || null);\n}\n\nvar PENDING = {};\nvar SUCCESS = {};\nvar FAILURE = {};\n\nfunction removeFromStore() {\n\tthis.store._remove(this);\n}\n\nvar proto = {\n\tdestroy,\n\tget,\n\tfire,\n\ton,\n\tset,\n\t_recompute: noop,\n\t_set,\n\t_stage,\n\t_mount,\n\t_differs\n};\n\nvar protoDev = {\n\tdestroy: destroyDev,\n\tget,\n\tfire,\n\ton,\n\tset: setDev,\n\t_recompute: noop,\n\t_set,\n\t_stage,\n\t_mount,\n\t_differs\n};\n\nexport { blankObject, destroy, destroyDev, _differs, _differsImmutable, fire, flush, get, init, on, set, _set, _stage, setDev, callAll, _mount, PENDING, SUCCESS, FAILURE, removeFromStore, proto, protoDev, wrapAnimation, fixPosition, handlePromise, append, insert, detachNode, detachBetween, detachBefore, detachAfter, reinsertBetween, reinsertChildren, reinsertAfter, reinsertBefore, destroyEach, createFragment, createElement, createSvgElement, createText, createComment, addListener, removeListener, setAttribute, setAttributes, setCustomElementData, setXlinkAttribute, getBindingGroupValue, toNumber, timeRangesToArray, children, claimElement, claimText, setData, setInputType, setStyle, selectOption, selectOptions, selectValue, selectMultipleValue, addResizeListener, toggleClass, destroyBlock, outroAndDestroyBlock, fixAndOutroAndDestroyBlock, updateKeyedEach, measure, animate, getSpreadUpdate, invalidAttributeNameCharacter, spread, escaped, escape, each, missingComponent, validateSsrComponent, debug, linear, generateRule, hash, wrapTransition, outros, groupOutros, transitionManager, noop, assign, assignTrue, isPromise, callAfter, addLoc, exclude, run };\n","<form ref:form class=\"row\" on:submit=\"setPlayers(event)\">\n\n    <div>\n        <input ref:newplayer type=\"text\" name=\"players\" placeholder=\"Add a player\">\n        <button class=\"button button-primary\">Add</button>\n    </div>\n    {#each $players as player, i}\n    <div>\n        <input type=\"text\" value=\"{ player }\" name=\"players\">\n        <button type=\"button\" class=\"button\" title=\"Remove this player\" on:click=\"removePlayer(i)\">x</button>\n    </div>\n    {/each}\n\n    <div><input type=\"submit\" value=\"start\" on:click=\"start(event)\"></div>\n</form>\n\n<style></style>\n\n<script>\n\nexport default {\n\n    methods: {\n\n        setPlayers(e) {\n            e.preventDefault();\n\n            const { form, newplayer } = this.refs;\n            let players;\n\n            if (form.elements.players.length) {\n                players = Array.from(form.elements.players)\n                    .map(i => i.value)\n                    .filter(Boolean);\n            } else {\n                players = [form.elements.players.value];\n            }\n\n            this.store.set({ players });\n            newplayer.value = \"\";\n        },\n\n        removePlayer(index) {\n            const players = this.store.get()['players']\n                .filter((p, i) => i !== index);\n            \n            this.store.set({ players });\n        },\n\n        start(e) {\n            // make sure players are set first\n            this.setPlayers.call(this, e);\n            this.store.set({ started: true });\n        }\n    }\n}\n</script>","var camel2hyphen = function (str) {\n  return str\n          .replace(/[A-Z]/g, function (match) {\n            return '-' + match.toLowerCase();\n          })\n          .toLowerCase();\n};\n\nmodule.exports = camel2hyphen;","var camel2hyphen = require('string-convert/camel2hyphen');\n\nvar isDimension = function (feature) {\n  var re = /[height|width]$/;\n  return re.test(feature);\n};\n\nvar obj2mq = function (obj) {\n  var mq = '';\n  var features = Object.keys(obj);\n  features.forEach(function (feature, index) {\n    var value = obj[feature];\n    feature = camel2hyphen(feature);\n    // Add px to dimension features\n    if (isDimension(feature) && typeof value === 'number') {\n      value = value + 'px';\n    }\n    if (value === true) {\n      mq += feature;\n    } else if (value === false) {\n      mq += 'not ' + feature;\n    } else {\n      mq += '(' + feature + ': ' + value + ')';\n    }\n    if (index < features.length-1) {\n      mq += ' and '\n    }\n  });\n  return mq;\n};\n\nvar json2mq = function (query) {\n  var mq = '';\n  if (typeof query === 'string') {\n    return query;\n  }\n  // Handling array of media queries\n  if (query instanceof Array) {\n    query.forEach(function (q, index) {\n      mq += obj2mq(q);\n      if (index < query.length-1) {\n        mq += ', '\n      }\n    });\n    return mq;\n  }\n  // Handling single media query\n  return obj2mq(query);\n};\n\nmodule.exports = json2mq;","<!-- only render if query matches current media -->\n{#if matches}\n<slot></slot>\n{/if}\n\n<script>\nexport default {\n\n    data() {\n        return {\n            matches: true,\n            query: null\n        }\n    },\n\n    oncreate() {\n        \n        const {query} = this.get();\n\n        this.updateMatches = this.updateMatches.bind(this);\n        \n        this.mediaQueryList = window.matchMedia(query);\n        this.mediaQueryList.addListener(this.updateMatches);\n\n        this.updateMatches();\n    },\n\n    ondestroy() {\n        if (this.mediaQueryList) {\n            this.mediaQueryList.removeListener(this.updateMatches);\n        }\n    },\n\n    methods: {\n        updateMatches(e) {\n            if (this.mediaQueryList) {\n                this.set({ matches: this.mediaQueryList.matches });\n            }\n        }\n    }\n}\n</script>","<div class=\"row\">\n    <Media query={ json2mq({ maxWidth: 600 }) }>\n        <div class=\"twelve columns\">\n            {#each $rounds as round, i}\n\n            <header>\n                <h2>Round { i+1 }</h2>\n                <button class=\"x-round button\" on:click=\"removeRound(i)\">X</button>\n            </header>\n\n            <dl>\n                {#each $players as player}\n                <dt>\n                    <label>\n                        <span>{ player }</span>\n                        <input type=\"number\" value=\"{ round[player] }\" \n                            on:input=\"updateScore(event, player, i)\">\n                    </label>\n                </dt>\n                {/each}\n            </dl>\n            {/each}\n        </div>\n    </Media>\n\n    <Media query={ json2mq({ minWidth: 601 }) }>\n    <table class=\"twelve columns\">\n        <thead>\n            <tr>\n                <th>Round #</th>\n                {#each $players as player, i}\n                <th>{ player }</th>\n                {/each}\n                <th>Discard</th>\n            </tr>\n        </thead>\n        <tbody>\n            {#each $rounds as round, i}\n            <tr>\n                <td>\n                    { i+1 } \n                </td>\n                {#each $players as player}\n                <td>\n                    <input type=\"number\" value=\"{ round[player] }\" on:input=\"updateScore(event, player, i)\">\n                </td>\n                {/each}\n\n                <td>\n                    <button class=\"x-round button\" on:click=\"removeRound(i)\">x</button>\n                </td>\n            </tr>\n            {/each}\n\n            <tr class=\"totals\">\n                <td>Totals:</td>\n                {#each $players as player}\n                <td>{ totals[player] || 0 }</td>\n                {/each}\n                <td></td>\n            </tr>\n        </tbody>\n    </table>\n    </Media>\n\n    <div>\n        <button class=\"button button-primary\" on:click=\"nextRound()\">Next round</button>\n        <button class=\"button\" on:click=\"$set({ started: false })\">Change players</button>\n    </div>\n</div>\n\n<style>\nheader {\n    display: flex;\n    flex-flow: row nowrap;\n    align-items: center;\n    justify-content: space-between;    \n}\n\nh2 {\n    font-size: 2em;\n}\n\nbutton.x-round {\n    background: none;\n    cursor: pointer;\n    border: none;\n    font-size: 1em;\n}\n\ndt label {\n    display: flex;\n    flex-flow: row nowrap;\n    align-items: center;\n    justify-content: space-around;    \n}\n</style>\n\n<script>\nimport json2mq from 'json2mq';\nimport Media from './Media.html';\nimport { totals } from './helpers.js';\n\nexport default {\n\n    components: { Media },\n\n    oncreate() {\n        const { rounds } = this.store.get();\n\n        if (rounds.length < 1) {\n            this.nextRound();\n        }\n    },\n\n    computed: {\n        totals: ({ $rounds }) => totals($rounds)\n    },\n\n    helpers: {\n        json2mq\n    },\n\n    methods: {\n        nextRound() {\n\n            const { rounds, players } = this.store.get();\n\n            const round = players.reduce((m, p) => {\n                m[p] = 0;\n                return m;\n            }, {});\n\n            rounds.push(round);\n\n            this.store.set({ rounds });\n        },\n\n        removeRound(index) {\n            let { rounds } = this.store.get();\n            \n            rounds = rounds.filter((r, i) => i !== index);\n\n            this.store.set({ rounds });\n        },\n\n        updateScore(e, player, index) {\n\n            const { rounds } = this.store.get();\n            const value = +e.target.value;\n\n            const updated = rounds.map((round, i) => {\n\n                if (i === index) {\n                    round[player] = value;\n                }\n\n                return round;\n            });\n\n            this.store.set({ rounds: updated });\n        }\n    }\n}\n</script>","<div class=\"container\">\n    <h1>Scorekeeper</h1>\n\n    {#if $started}\n        <Play ref:play />\n    {:else}\n        <ChoosePlayers ref:choose />\n    {/if}\n</div>\n\n<script>\nimport ChoosePlayers from './ChoosePlayers.html'\nimport Play from './Play.html'\n\nexport default {\n\tcomponents: {\n        ChoosePlayers,\n        Play\n\t}\n}\n</script>\n","import {\n\tassign,\n\tblankObject,\n\t_differs,\n\t_differsImmutable,\n\tget,\n\ton,\n\tfire\n} from './shared.js';\n\nfunction Store(state, options) {\n\tthis._handlers = {};\n\tthis._dependents = [];\n\n\tthis._computed = blankObject();\n\tthis._sortedComputedProperties = [];\n\n\tthis._state = assign({}, state);\n\tthis._differs = options && options.immutable ? _differsImmutable : _differs;\n}\n\nassign(Store.prototype, {\n\t_add(component, props) {\n\t\tthis._dependents.push({\n\t\t\tcomponent: component,\n\t\t\tprops: props\n\t\t});\n\t},\n\n\t_init(props) {\n\t\tconst state = {};\n\t\tfor (let i = 0; i < props.length; i += 1) {\n\t\t\tconst prop = props[i];\n\t\t\tstate['$' + prop] = this._state[prop];\n\t\t}\n\t\treturn state;\n\t},\n\n\t_remove(component) {\n\t\tlet i = this._dependents.length;\n\t\twhile (i--) {\n\t\t\tif (this._dependents[i].component === component) {\n\t\t\t\tthis._dependents.splice(i, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t},\n\n\t_set(newState, changed) {\n\t\tconst previous = this._state;\n\t\tthis._state = assign(assign({}, previous), newState);\n\n\t\tfor (let i = 0; i < this._sortedComputedProperties.length; i += 1) {\n\t\t\tthis._sortedComputedProperties[i].update(this._state, changed);\n\t\t}\n\n\t\tthis.fire('state', {\n\t\t\tchanged,\n\t\t\tprevious,\n\t\t\tcurrent: this._state\n\t\t});\n\n\t\tthis._dependents\n\t\t\t.filter(dependent => {\n\t\t\t\tconst componentState = {};\n\t\t\t\tlet dirty = false;\n\n\t\t\t\tfor (let j = 0; j < dependent.props.length; j += 1) {\n\t\t\t\t\tconst prop = dependent.props[j];\n\t\t\t\t\tif (prop in changed) {\n\t\t\t\t\t\tcomponentState['$' + prop] = this._state[prop];\n\t\t\t\t\t\tdirty = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (dirty) {\n\t\t\t\t\tdependent.component._stage(componentState);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.forEach(dependent => {\n\t\t\t\tdependent.component.set({});\n\t\t\t});\n\n\t\tthis.fire('update', {\n\t\t\tchanged,\n\t\t\tprevious,\n\t\t\tcurrent: this._state\n\t\t});\n\t},\n\n\t_sortComputedProperties() {\n\t\tconst computed = this._computed;\n\t\tconst sorted = this._sortedComputedProperties = [];\n\t\tconst visited = blankObject();\n\t\tlet currentKey;\n\n\t\tfunction visit(key) {\n\t\t\tconst c = computed[key];\n\n\t\t\tif (c) {\n\t\t\t\tc.deps.forEach(dep => {\n\t\t\t\t\tif (dep === currentKey) {\n\t\t\t\t\t\tthrow new Error(`Cyclical dependency detected between ${dep} <-> ${key}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tvisit(dep);\n\t\t\t\t});\n\n\t\t\t\tif (!visited[key]) {\n\t\t\t\t\tvisited[key] = true;\n\t\t\t\t\tsorted.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const key in this._computed) {\n\t\t\tvisit(currentKey = key);\n\t\t}\n\t},\n\n\tcompute(key, deps, fn) {\n\t\tlet value;\n\n\t\tconst c = {\n\t\t\tdeps,\n\t\t\tupdate: (state, changed, dirty) => {\n\t\t\t\tconst values = deps.map(dep => {\n\t\t\t\t\tif (dep in changed) dirty = true;\n\t\t\t\t\treturn state[dep];\n\t\t\t\t});\n\n\t\t\t\tif (dirty) {\n\t\t\t\t\tconst newValue = fn.apply(null, values);\n\t\t\t\t\tif (this._differs(newValue, value)) {\n\t\t\t\t\t\tvalue = newValue;\n\t\t\t\t\t\tchanged[key] = true;\n\t\t\t\t\t\tstate[key] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthis._computed[key] = c;\n\t\tthis._sortComputedProperties();\n\n\t\tconst state = assign({}, this._state);\n\t\tconst changed = {};\n\t\tc.update(state, changed, true);\n\t\tthis._set(state, changed);\n\t},\n\n\tfire,\n\n\tget,\n\n\ton,\n\n\tset(newState) {\n\t\tconst oldState = this._state;\n\t\tconst changed = this._changed = {};\n\t\tlet dirty = false;\n\n\t\tfor (const key in newState) {\n\t\t\tif (this._computed[key]) throw new Error(`'${key}' is a read-only computed property`);\n\t\t\tif (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;\n\t\t}\n\t\tif (!dirty) return;\n\n\t\tthis._set(newState, changed);\n\t}\n});\n\nexport { Store };\n","// helpers outside of components\n\nexport function totals(rounds) {\n    return rounds.reduce((m, round) => {\n        for (let player in round) {\n            m[player] = (m[player] || 0) + round[player];\n        }\n\n        return m;\n    }, {});\n}\n\nexport function useLocalStorage(store, key) {\n    const json = localStorage.getItem(key);\n    if (json) {\n        store.set(JSON.parse(json));\n    }\n\n    store.on('state', ({ current, previous, changed }) => {\n        localStorage.setItem(key, JSON.stringify(current));\n    });\n}","import App from './App.html';\nimport { Store } from 'svelte/store.js';\nimport { totals, useLocalStorage } from './helpers.js';\n\nconst store = new Store({\n\tplayers: [],\n    rounds: [],\n    started: false\n});\n\nwindow.store = store;\n\n// save data to localStorage every time our state changes\nuseLocalStorage(store, 'scorekeeper');\n\nconst app = new App({\n\ttarget: document.body,\n\tstore\n});\n\nexport default app;"],"names":["noop","assign","tar","src","k","assignTrue","run","fn","append","target","node","appendChild","insert","anchor","insertBefore","detachNode","parentNode","removeChild","destroyEach","iterations","detach","i","length","d","createFragment","document","createDocumentFragment","createElement","name","createText","data","createTextNode","createComment","addListener","event","handler","options","addEventListener","removeListener","removeEventListener","setAttribute","attribute","value","removeAttribute","setData","text","blankObject","Object","create","_differs","a","b","_differsImmutable","fire","eventName","handlers","this","_handlers","slice","__calling","call","flush","component","_lock","callAll","_beforecreate","_oncreate","_aftercreate","get","_state","init","_slots","_bind","_staged","root","store","on","push","cancel","index","indexOf","splice","fns","shift","removeFromStore","_remove","proto","destroy","set","_fragment","newState","_set","_recompute","oldState","changed","dirty","key","current","previous","p","_stage","_mount","[object Object]","e","preventDefault","form","newplayer","refs","players","elements","Array","from","map","filter","Boolean","setPlayers","started","removePlayer","player","$players","start","str","replace","match","toLowerCase","obj2mq","obj","mq","features","keys","forEach","feature","test","isDimension","camel2hyphen","query","q","mediaQueryList","matches","updateMatches","before","after","nextSibling","bind","window","matchMedia","rounds","round","reduce","m","r","updated","removeRound","updateScore","totals","$rounds","json2mq","maxWidth","minWidth","nextRound","$started","Store","state","_dependents","_computed","_sortedComputedProperties","immutable","prototype","props","prop","update","dependent","componentState","j","computed","sorted","visited","currentKey","visit","c","deps","dep","Error","values","newValue","apply","_sortComputedProperties","_changed","json","localStorage","getItem","JSON","parse","setItem","stringify","useLocalStorage","App","body"],"mappings":"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"}